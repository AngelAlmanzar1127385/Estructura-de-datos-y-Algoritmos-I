#include <iostream>
using namespace std;

struct Nodo {

	int dato;
	Nodo* der;
	Nodo* izq;
	Nodo* bardock;

};

Nodo* crearNodo(int n, Nodo *padre)
{
	Nodo* nuevo_nodo = new Nodo();

	nuevo_nodo->dato = n;
	nuevo_nodo->der = nullptr;
	nuevo_nodo->izq = nullptr;
	nuevo_nodo->bardock = padre;

	return nuevo_nodo;

}

void insertarNodo(Nodo*& arbol, int n,Nodo* padre)
{

	if (arbol == nullptr)
	{
		Nodo* nuevonodo = crearNodo(n, padre);
		arbol = nuevonodo;
		
		//si el arbol esta vacio
		//esta sera la raiz del arbol
	}
	else //si el arbol tiene un nodo o mas
	{
		int goku = arbol->dato;
		//variable para saber el valor de la raiz
		//es para saber si lo mandamos al lado izquierdo 
		//o al lado derecho

		if (n < goku)
		{
		insertarNodo(arbol->izq, n, arbol);
			
		}
		else
		{
		insertarNodo(arbol->der, n, arbol);
			
		}
	}

}

void mostrarArbol(Nodo* arbol, int moises)
{
	if (arbol == nullptr)
	{
		return;
	}
	else
	{
		mostrarArbol(arbol->der, moises+1);
		for (int i = 0; i < moises; i++)
		{
			cout << "   ";
		}
		cout << arbol->dato << endl;
		mostrarArbol(arbol->izq, moises+1);
	}

}

bool busqueda(Nodo*arbol,int n)
{
	if (arbol == nullptr)
	{
		return false; 
	}
	else if(arbol->dato == n)
	{
		return true;
	}
	else if (n < arbol->dato)
	{
		return busqueda(arbol->izq, n);
	}
	else
	{
		return busqueda(arbol->der, n);
	}
}

void preOrden(Nodo*arbol)
{
	if (arbol == nullptr)
	{
		return;
	}
	else
	{
		cout << arbol->dato << "-";
		preOrden(arbol->izq);
		preOrden(arbol->der);

	}



}

void inOrden(Nodo*arbol)
{
	if (arbol == nullptr)
	{
		return;
	}
	else
	{
		inOrden(arbol->izq);
		cout << arbol->dato << "-";
		inOrden(arbol->der);
	}


}

void postOrden(Nodo*arbol)
{
	if (arbol == nullptr)
	{
		return;
	}
	else
	{
		postOrden(arbol->izq);
		postOrden(arbol->der);
		cout << arbol->dato << "-";
	}
}

//Aqui empieza la funcion eliminar con sus respectivos metodos
//para que funcione correctamente

void jalofeinNodo(Nodo* nodo)
{
	nodo->izq = nullptr;
	nodo->der = nullptr;

	delete nodo;
}

Nodo* minimo(Nodo* arbol)
{
	//funcion para determinar el nodo mas izquierdo posible

	if (arbol == nullptr) return nullptr;
	
	if (arbol->izq)//si tiene hijo izquierdo
	{
		return minimo(arbol->izq);//buscamos la parte mas izq posible
	}
	else //si no tiene hijo izq
	{
		return arbol;//retornamos el mismo nodo
	}

}

void reemplazar(Nodo* arbol, Nodo* nuevoNodo)
{
	//hay que saber quien es el padre del nodo que queremos eliminar
	//ya que ese padre apuntara al hijo del nodo que eliminaremos
	//solo seria en el caso de que el nodo a eliminar tenga un solo hijo
	if (arbol->bardock)
	{
		if (arbol->bardock->izq)
		{
			//arbol->bardock hay que asignarle su nuevo hijo
			if (arbol->bardock->izq == arbol)
			{
				arbol->bardock->izq = nuevoNodo;
			}
			else if (arbol->dato == arbol->bardock->der->dato)
			{
				arbol->bardock->der = nuevoNodo;
			}
		}
		
	}
	if (nuevoNodo)
	{
		//tambien se le tiene que asignar su nuevo padre
		nuevoNodo->bardock = arbol->bardock;
	}

}

void eliminarNodo(Nodo* nodoEliminar)
{
	//funcion para eliminar el nodo encontrado

	//borrar un nodo con dos subarboles hijos
	//podemos confirmarlo preguntando si tiene hijo derecho
	//e hijo izquierdo
	if (nodoEliminar->izq && nodoEliminar->der)
	{
		Nodo* menor = minimo(nodoEliminar->der);
		nodoEliminar->dato = menor->dato;
		eliminarNodo(menor);
	}
	//ahora seria si tiene un solo hijo izquierdo
	else if (nodoEliminar->izq)//si tiene hijo izquierdo
	{
		reemplazar(nodoEliminar, nodoEliminar->izq);
		jalofeinNodo(nodoEliminar);
	}
	else if (nodoEliminar->der)
	{
		reemplazar(nodoEliminar, nodoEliminar->der);
		jalofeinNodo(nodoEliminar);
	}
	else
	{
		//si no tiene hijos (nodo hoja)
		reemplazar(nodoEliminar, nullptr);
		jalofeinNodo(nodoEliminar);
	}

}

Nodo* eliminar(Nodo*& arbol, int n)
{
	if (arbol == nullptr)//si el arbol esta vacio
	{
		return;
		//no se hace nada
	}
	else if (n < arbol->dato)//si el valor es menor
	{
		eliminar(arbol->izq, n);
		//busca por la izquierda
	}
	else if (n > arbol->dato)//si el valor es mayor
	{
		eliminar(arbol->der, n);
		//busca por la derecha
	}
	else //si ya se encontro el valor del nodo
	{
		eliminarNodo(arbol);
	}

	// Cambia la firma de eliminar para que retorne Nodo*
	Nodo* eliminar(Nodo * arbol, int n)
	{
		if (arbol == nullptr)//si el arbol esta vacio
		{
			return nullptr;
			//no se hace nada
		}
		else if (n < arbol->dato)//si el valor es menor
		{
			arbol->izq = eliminar(arbol->izq, n);
			//busca por la izquierda
		}
		else if (n > arbol->dato)//si el valor es mayor
		{
			arbol->der = eliminar(arbol->der, n);
			//busca por la derecha
		}
		else //si ya se encontro el valor del nodo
		{
			eliminarNodo(arbol);
		}
		return arbol;
	}


//Aqui termina eliminar

int validar(string mensaje, string mensajeError) {

	int majinbuu;
	bool casimiroFortnite = true;

	while (casimiroFortnite) {

		cout << mensaje;  // Mostramos mensaje de entrada
		cin >> majinbuu;      // Leemos dato

		// Si hubo error de entrada o caracteres no válidos
		if (cin.fail() || cin.peek() != '\n') {
			cout << mensajeError << endl << endl;
			cin.clear();            // Limpiar estado de error
			cin.ignore(100, '\n');  // Ignorar lo que sobra en el buffer
			casimiroFortnite = true;          // Repetimos
		}
		
		else {

			casimiroFortnite = false; // Entrada válida
			return majinbuu;
		}
	}
}

void LimpiarConsola() {

	system("pause");
	system("cls");
}

int main()
{
	int dato, opcion, moises=0,bardock;
	Nodo* arbol = nullptr;
	bool gohan = true;

	while (gohan)
	{

		cout << "\n:::: MENU DE ARBOL DE BUSQUEDA BINARIA::::\n";
		cout << "\n";
		cout << "1. Insertar un nuevo nodo\n";
		cout << "2. Mostrar el arbol completo\n";
		cout << "3. Buscar un elemento en el arbol\n";
		cout << "4. Recorrer el arbol en PreOrden\n";
		cout << "5. Recorrer el arbol en InOrden\n";
		cout << "6. Recorrer el arbol en PostOrden\n";
		cout << "7. Eliminar un nodo\n";
		cout << "8. Salir\n";

		opcion = validar("\nSeleccione la opcion: ", "Dato Invalido, intente nuevamente");

		switch (opcion)
		{
		case 1:

			dato = validar("Ingrese un dato: ", "Dato invalido, intente nuevamente");
			insertarNodo(arbol, dato, NULL);
			cout << "\n";
			break;

		case 2:

			if (arbol == NULL)
			{
				cout << "El arbol esta vacio\n";
				break;
			}
			cout << "Mostrando el arbol completo:\n";
			cout << "\n\n";
			mostrarArbol(arbol, moises);
			cout << "\n";
			break;

		case 3:

			if (arbol == NULL)
			{
				cout << "El arbol esta vacio\n";
				break;
			}
			dato = validar("Ingrese el dato a buscar: ", "Dato invalido, intente nuevamente");
			if (busqueda(arbol,dato) == true)
			{
				cout << "\nElemento " << dato << " ha sido encontrado en el arbol";
			}
			else
			{
				cout << "\nElemento no encontrado";
			}
			cout << "\n";
			break;
			

		case 4:

			if (arbol == NULL)
			{
				cout << "El arbol esta vacio\n";
				break;
			}
			cout << "Recorrido en PreOrden\n";
			preOrden(arbol);
			cout << "\n\n";
			break;

		case 5:

			if (arbol == NULL)
			{
				cout << "El arbol esta vacio\n";
				break;
			}
			cout << "Recorrido en InOrden\n";
			inOrden(arbol);
			break;

		case 6:

			if (arbol == NULL)
			{
				cout << "El arbol esta vacio\n";
				break;
			}
			cout << "Recorrido en PostOrden\n";
			postOrden(arbol);
			break;

		case 7:

			if (arbol == NULL)
			{
				cout << "El arbol esta vacio\n";
				break;
			}
			dato = validar("Ingrese el dato a eliminar: ", "Dato invalido, intente nuevamente");
			eliminar(arbol, dato);
			cout << "\n";
			break;


		case 8:

			cout << "Saliendo del programa\n";
			gohan = false;
			break;

		default:
			cout << "Esta opcion no esta disponible" << "\n";
			break;
		}

		LimpiarConsola();
	}


}
